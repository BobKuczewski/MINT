; *************************************************************************
;
;        MINT_1.5 Micro-Interpreter for the Z80 based on SIMPL
;
;        Ken Boak October 19th 2021  
;        Length  881 bytes
;
;        Includes serial routines getchar and putchar
;        printstring
;        printdec
;        printhex
;        crlf
;
;        Register Assignment:
;
;        BC is the instruction pointer IP
;        DE is a working register and 2nd on stack NOS
;        HL is a working register and Top of stack TOS
;        SP is data stack pointer
;        IY is used as a jump back to NEXT
;
;        MINT consists of 4 major sections:
;
;        1.  An interpreter kernel and serial interface routines   250 bytes
;
;        2.  A vector table to dispatch the 96 possible opcodes    192 bytes
;
;        3.  An area containing the Primitive function code fields: up to 582 bytes
;
;        4.  A text buffer area to hold keyboard input and User routines  up to 1K bytes
;
;        The first 3 can be placed in a 1K ROM or RAM, the last item requires at least 1K RAM
;        
;        For simplicity on a modern system, everything is placed in RAM.
;
;
;
;        New in this version 1.5:
;
;        JP NEXT replaced with JP (IY) saves 2 ticks and 36 bytes  
;
;		 Improved math operations
;
;
;        User defined commands and variables
;
;        User Commands  A-Z
;        User Variables a-z
;
;        Commands now available:
;
;        Maths
;
;        +     ADD
;		 -     SUB
;        *     MUL     (max product 65535)
;        /     DIV
;        %     MOD
;        _     NEG
;
;        Comparison - compare the top two elements on the stack
;        Puts 1 on the stack if condition is true, 0 if false
;
;        <     LT
;        =     EQ
;        >     GT
;
;        Logic
;
;        &     AND
;        |     OR
;        ^     XOR
;        ~     INV
;
;        Stack
;
;        "     DUP
;        '     DROP
;        $     SWAP
;        .     DOT     (Print the value of the top of stack as a decimal)
;
;        Memory
;
;        @     FETCH
;        !     STORE
;
;        User Definitions
;
;        :     Start a user definition
;        ;     End a user definition
;
;        \     QUIT    (Print OK and return to monitor)
;
;
;       Loops    - execute the code between parenthesis
;
;       The user variable i is used as the loop counter
;       It is decremented every time the loop is executed
;
;       10(repeat this code 10 times)
;
;        0(skip this code)
;
;        1(execute this code only once)
;
;       a@ b@ = (_print this if a=b_)
;
;       1000(i@.)    Print out the value of i from 999 to 0
;
;       10(a@ 1+ a! a@ .)  Increment a 10 times and print it out
;
;       User Commands are allocated to uppercase alpha characters A to Z
;
;       A user command can be defined by starting with a colon and
;       ending with a semicolon
;
;       Example  :A 123 456 + . ;
;
;       The A character represents a fixed address for the User routine
;       The interpreter copies all the characters after the A to a text buffer
;       located at address A
;       Each time A is encountered (outside of a colon definition)
;       it will execute the code  located there i.e. 123 456 + .
;
;       Variables are associated with lowercase characters a-z
;       Each variable is allocated 2 bytes located on even addresses
;       They run contiguously from $A800 (a) to $A830 (z)
;       They are accessed using the fetch and store commands @ and !
;
;       Examples:
;
;       1234 a!     store 1234 in a
;
;       b@ .        fetch the value from b and print it out
;
;       a@ b@ + .   fetch values from a and b, add them together and print the sum
;
;       a@ b!       copy the value in a and store it in b
;
;
; *****************************************************************************

        ROMSIZE     EQU $800
        DSIZE       EQU $100
        RSIZE       EQU $100
        VTSIZE      EQU $100
        TBUFSIZE    EQU $100
        TRUE        EQU -1
        FALSE       EQU 0

        stringbuf EQU  $8800
        
        usertab   EQU  $A4     ; Upper byte of user table
        
        vartab    EQU  $A8     ; Upper byte of variables table
        
        loopstart EQU  $A760   ; Loop code storage area
        
        loopcount EQU  $A810   ; Hold the loopcounter in variable i

        .ORG 0
ROMSTART:            
        .ORG $100
        
itable:            
        DW      0           ; NUL
        DW      0           ; SOH
        DW      0           ; STX
        DW      0           ; ETX
        DW      0           ; EOT
        DW      0           ; ENQ
        DW      0           ; ACK
        DW      0           ; BEL
        DW      0           ; BS
        DW      0           ; TAB
        DW      0           ; LF
        DW      0           ; VT
        DW      0           ; FF
        DW      interpret    ; CR
        DW      0           ; SO
        DW      0           ; SI
        DW      0           ; DLE
        DW      0           ; DC1
        DW      0           ; DC2
        DW      0           ; DC3
        DW      0           ; DC4
        DW      0           ; NAK
        DW      0           ; SYN
        DW      0           ; ETB
        DW      0           ; CAN
        DW      0           ; EM
        DW      0           ; SUB
        DW      0           ; ESC
        DW      0           ; FS
        DW      0           ; GS
        DW      0           ; RS
        DW      0           ; US
        DW      space       ; SP
        DW      store       ; !   
        DW      dup_        ; "
        DW      lit_        ; #
        DW      swap        ; $   
        DW      mod_        ; %   
        DW      and_        ; &
        DW      drop        ; '
        DW      begin_      ; (  
        DW      end_        ; )
        DW      mul_        ; *   
        DW      add_        ; +
        DW      quit        ; ,   
        DW      sub_        ; -
        DW      dot_        ; .
        DW      div_        ; /
        DW      num_        ; 0   
        DW      num_        ; 1  
        DW      num_        ; 2   
        DW      num_        ; 3
        DW      num_        ; 4   
        DW      num_        ; 5   
        DW      num_        ; 6   
        DW      num_        ; 7
        DW      num_        ; 8   
        DW      num_        ; 9  
        DW      def_        ; :  
        DW      ret_        ; ;
        DW      lt_         ; <
        DW      eq_         ; =   
        DW      gt_         ; >   
        DW      query       ; ?
        DW      fetch       ; @ 
        DW      $A420       ; A 
        DW      $A440       ; B
        DW      $A460       ; C
        DW      $A480       ; D 
        DW      $A4A0       ; E
        DW      $A4C0       ; F
        DW      $A4E0       ; G
        DW      $A500       ; H
        DW      $A520       ; I
        DW      $A540       ; J
        DW      $A560       ; K
        DW      $A580       ; L
        DW      $A5A0       ; M
        DW      $A5C0       ; N
        DW      $A5E0       ; O
        DW      $A600       ; P
        DW      $A620       ; Q
        DW      $A640       ; R
        DW      $A660       ; S
        DW      $A680       ; T
        DW      $A6A0       ; U
        DW      $A6C0       ; V
        DW      $A6E0       ; W
        DW      $A700       ; X
        DW      $A720       ; Y
        DW      $A740       ; Z
        DW      open        ; [
        DW      quit        ; \
        DW      close       ; ]
        DW      xor_        ; ^
        DW      str_        ; _
        DW      tick        ; `   
        DW      $A800       ; a
        DW      $A802       ; b
        DW      $A804       ; c
        DW      $A806       ; d
        DW      $A808       ; e
        DW      $A80A       ; f
        DW      $A80C       ; g
        DW      $A80E       ; h
        DW      $A810       ; i   
        DW      $A812       ; j
        DW      $A814       ; k
        DW      $A816       ; l
        DW      $A818       ; m
        DW      $A81A       ; n
        DW      $A81C       ; o
        DW      $A81E       ; p
        DW      $A820       ; q   
        DW      $A822       ; r
        DW      $A824       ; s 
        DW      $A826       ; t
        DW      $A828       ; u
        DW      $A82A       ; v
        DW      $A82A       ; w
        DW      $A82C       ; x
        DW      $A82E       ; y
        DW      $A830       ; z
        DW      save        ; {
        DW      or_         ; |   
        DW      load        ; }   
        DW      inv_        ; ~   
        DW      del_        ; 

        .ORG $200
init:
        LD IX,RSTACK
        LD IY,NEXT			   ; IY provides a faster jump to NEXT
        CALL initVTable
        LD BC,HEAPSTART
        LD (HERE),BC
        LD (HERE1),BC
        LD A,FALSE
        LD (DEFINE),A

interpret:
        CALL crlf
        CALL ok                ; friendly prompt
        CALL crlf              ; newline
        LD A,(DEFINE)
        OR A
        JR NZ,inchar
        LD BC,(HERE1)
        LD (HERE),BC
        JR waitchar
inchar:
        LD BC,(HERE)        ; input buffer is at $8100      
        LD (HERE1),BC

; *******************************************************************         
; Wait for a character from the serial input (keyboard) 
; and store it in the text buffer. Keep accepting characters,
; increasing the instruction pointer BC - until a newline received.
; *******************************************************************

waitchar:   
        CALL getchar        ; loop around waiting for character
        CP $0A              ; Less than $0A
        JR C, endchar       ; Return char
        CP $7F              ; Greater or equal to $7F
        JR NC, endchar             

        LD (BC), A          ; store the character in textbuf
        INC BC
        CP  $0D             ; is it a newline?
        JR Z, endchar
        
        CP ":"
        JR NZ,waitchar1
        
        EX AF,AF'           ; TODO: clarify free register use
        LD A,TRUE
        LD (DEFINE),A
        EX AF,AF'
        
waitchar1:        
        CALL putchar        ; echo character to screen
        
        JR  waitchar        ; wait for next character
        
endchar:    
        LD (HERE),BC
        LD A, $0D           ; Send out a CRLF
        CALL putchar
        LD A, $0A
        CALL putchar
			
; ********************************************************************************
; Number Handling Routine - converts numeric ascii string to a 16-bit number in HL
; On receipt of a newline character, reset BC to the start of the text buffer
; Read the first character. If not a number (0-9) jump to the dispatch routine
;			
; Number characters ($30 to $39) are converted to digits by subtracting $30
; and then added into the L register. (HL forms a 16-bit accumulator)
; Fetch the next character, if it is a number, multiply contents of HL by 10
; and then add in the next digit. Repeat this until a non-number character is 
; detected. Add in the final digit so that HL contains the converted number.
; Push HL onto the stack and proceed to the dispatch routine.
; ********************************************************************************
         
        LD BC,(HERE1)           ; Instructions begin at $8100
        DEC BC
        
NEXT:   LD HL, $0000            ; 10t   Clear HL to accept new number
        INC BC                  ; 6t    Increment the IP
        LD A, (BC)              ; 7t    Get the next character
        CP $30                  ; 7t    Less that $30
        JR C, dispatch          ; 7/12t Not a number
        CP $3A                  ; 7t    Greater or equal to $3A
        JR NC, dispatch         ; 7/12t Not a number
        
        SUB $30                 ; 7t    Form decimal digit
        ADD A,L                 ; 4t    Add into bottom of HL
        LD  L,A                 ; 4t
      
number1:                               
        INC BC                  ; 6t    Increment IP
        LD A, (BC)              ; 7t    Get the next character
        CP $30                  ; 7t    Less than $30
        JR C, endnum            ; 7/12t Not a number / end of number
        CP $3A                  ; 7t    Greater or equal to $3A
        JR NC, endnum           ; 7/12t Not a number / end of number
       
times10:                        ; Multiply digit(s) in HL by 10
        ADD HL,HL               ; 11t    2 X
        LD  E,L                 ;  4t    LD DE,HL
        LD  D,H                 ;  4t
        ADD HL,HL               ; 11t    4 X
        ADD HL,HL               ; 11t    8 X
        ADD HL,DE               ; 11t    10 X
                                ; 52t cycles
        
        SUB $30                 ;  7t   Form next decimal digit in A
        ADD A,L                 ;  4t   Add into bottom of HL
        LD  L,A                 ;  4t
                                ;  15t cycles
        
        JP  number1
                
endnum:
        PUSH HL                ; 11t   Put the number on the stack
		 
; ********************************************************************************
; Dispatch Routine.
;
; At this stage, numbers have already been processed and placed on the stack
;
; Look up the jump address associated with each character
;
; The dispatch routine must provide a 3-way handling of remaining characters
;
; 1. Detect characters A-Z where their table address will begin $A4xx
; and handle it as a user command
;
; 2. Detect characters a-z where their table address will begin $A8xx
; and handle it as a user variable
;
; 3. All other characters are punctuation and cause a jump to the associated
; primitive code.
;
; The Instruction Pointer IP BC is pushed to preserve its contents.
; The current character from the text buffer is temporarily held in A.
; It is doubled so that it forms an even number and will point to even address.
; B is loaded with the high byte of the vector table VTABLE and the doubled		 
; value of A is loaded into C, so that it indexes into the vector table.
; At the selected table location is a 2-byte jump address to the selected function
; This target jump address is loaded into HL, and BC is restored.
; The routine uses HL to jump to the selected function.
; *********************************************************************************

dispatch:                       ; The character at IP is not a number

        PUSH BC                 ; 11t   Push the current IP
        ADD A,A                 ; 4t    Double A to index even addresses
        LD BC, VTABLE           ; 7t    Start address of jump table         
        LD C,A                  ; 4t    Index into table
        LD A,(BC)               ; 7t    get low jump address
        LD L,A                  ; 4t    and put into L
        INC BC                  ; 6t
        LD A,(BC)               ; 7t    Get high jump address
        LD H,A                  ; 4t    and put into H
        POP BC                  ; 10t   Get IP back
        
        ; Now check if the address relates to a user variable or definition        
        
        CP  vartab              ; Is H >= to user variable table start
        JR  NC, uservar
        
        CP  usertab             ; Is H >= to user definition table start
        JR  NC, userdef
        
        JP  (HL)                ; 4t Jump to routine
        
userdef:                        ; The character is a User Definition A-Z
        DEC IX                  ; save Instruction Pointer
        LD (IX+0),B
        DEC IX
        LD (IX+0),C
        
        LD B,H                  ; Instruction Pointer loaded with user address
        LD C,L
        DEC BC
        JP  (IY)                ; Execute code from User def
        
uservar:                        ; The character is a user variable a-z          
        PUSH HL                 ; push variable address on the stack
        JP   (IY)                     
        
initVTable:
        LD HL,itable
        LD DE,vtable
        LD BC,VTSIZE
        LDIR
        RET

; ************************SERIAL HANDLING ROUTINES**********************        
;
;        Includes drivers for 68B50 ACIA 
;		 serial interface I/O primitive routines getchar and putchar
;        printstring
;        printdec
;        printhex
;        crlf         

; **********************************************************************
; **  Device Driver                             by Stephen C Cousins  **
; **  Hardware:  RC2014                                               **
; **  Interface: Serial 6850 ACIA                                     **
; **********************************************************************

; This module is the driver for the RC2014 serial I/O interface which is
; based on the 6850 Asynchronous Communications Interface Adapter (ACIA)
;
; Base addresses for ACIA externally defined. eg:
kACIA1:    .EQU 0x80           ;Base address of serial ACIA #1
kACIA2:    .EQU 0x80           ;Base address of serial ACIA #2
;
; RC2014 addresses for 68B50 number 2:
; 0x40   Control registers (read and write)
; 0x41   Data registers (read and write)
;
; Control registers (read and write)
; Bit   Control write              Control read
;  0    Counter divide select 1    Receive data register full
;  1    Counter divide select 2    Transmit data register empty
;  2    Word select 1              Data carrier detect (/DCD) input
;  3    Word seelct 2              Clear to send (/CTS) input
;  4    Word select 3              Framing error
;  5    Transmit contol 1          Receiver overrun
;  6    Transmit control 2         Parity error
;  7    Receive interrupt enable   Interrupt request
;
; Control register write
; Bit   7   6   5   4   3   2   1   0
;       |   |   |   |   |   |   |   |
;       |   |   |   |   |   |   0   0     Clock divide 1
;       |   |   |   |   |   |   0   1     Clock divide 16
; >     |   |   |   |   |   |   1   0  >  Clock divide 64
;       |   |   |   |   |   |   1   1     Master reset
;       |   |   |   |   |   |
;       |   |   |   0   0   0     7 data bits, even parity, 2 stop bits
;       |   |   |   0   0   1     7 data bits, odd parity,  2 stop bits
;       |   |   |   0   1   0     7 data bits, even parity, 1 stop bit
;       |   |   |   0   1   1     7 data bits, odd parity,  1 stop bit
;       |   |   |   1   0   0     8 data bits, no parity,   2 stop bits
;       |   |   |   1   0   1  >  8 data bits, no parity,   1 stop bit
;       |   |   |   1   1   0     8 data bits, even parity, 1 stop bit
;       |   |   |   1   1   1     8 data bits, odd parity,  1 stop bit
;       |   |   |
;       |   0   0  >  /RTS = low (ready), tx interrupt disabled
;       |   0   1     /RTS = low (ready), tx interrupt enabled
;       |   1   0     /RTS = high (not ready), tx interrupt disabled 
;       |   1   1     /RTS = low, tx break, tx interrupt disabled
;       |
;       0  >  Receive interrupt disabled
;       1     Receive interrupt enabled
;
; Control register read
; Bit   7   6   5   4   3   2   1   0
;       |   |   |   |   |   |   |   |
;       |   |   |   |   |   |   |   +-------  Receive data register full
;       |   |   |   |   |   |   +-------  Transmit data register empty
;       |   |   |   |   |   +-------  Data carrier detect (/DCD)
;       |   |   |   |   +-------  Clear to send (/CTS)
;       |   |   |   +-------  Framing error
;       |   |   +-------  Receiver overrun 
;       |   +-------  Parity error
;       +-------  Interrupt request

; 6850 #1 registers derived from base address (above)
kACIA1Cont: .EQU kACIA1+0       ;I/O address of control register
kACIA1Data: .EQU kACIA1+1       ;I/O address of data register
; 6850 #2 registers derived from base address (above)
kACIA2Cont: .EQU kACIA2+0       ;I/O address of control register
kACIA2Data: .EQU kACIA2+1       ;I/O address of data register

; Control register values
k6850Reset: .EQU 0b00000011     ;Master reset
k6850Init:  .EQU 0b00010110     ;No int, RTS low, 8+1, /64

; Status (control) register bit numbers
k6850RxRdy: .EQU 0              ;Receive data available bit number
k6850TxRdy: .EQU 1              ;Transmit data empty bit number

; Device detection, test 1
; This test just reads from the devices' status (control) register
; and looks for register bits in known states:
; /CTS input bit = low
; /DCD input bit = low
; WARNING
; Sometimes at power up the Tx data reg empty bit is zero, but
; recovers after device initialised. So test 1 excludes this bit.
k6850Mask1: .EQU  0b00001100    ;Mask for known bits in control reg
k6850Test1: .EQU  0b00000000    ;Test value following masking

; Device detection, test 2
; This test just reads from the devices' status (control) register
; and looks for register bits in known states:
; /CTS input bit = low
; /DCD input bit = low
; Transmit data register empty bit = high
k6850Mask2: .EQU  0b00001110    ;Mask for known bits in control reg
k6850Test2: .EQU  0b00000010    ;Test value following masking

; RC2014 serial 6850 initialise
;   On entry: No parameters required
;   On exit:  Z flagged if device is found and initialised
;             AF BC DE HL not specified
;             IX IY I AF' BC' DE' HL' preserved
; If the device is found it is initialised
serial_init:
; First look to see if the device is present
; Test 1, just read from chip, do not write anything
        IN   A,(kACIA1Cont) ;Read status (control) register
        AND  k6850Mask1     ;Mask for known bits in control reg
        CP   k6850Test1     ;and check for known values
        RET  NZ             ;If not found return with NZ flag
; Attempt to initialise the chip
        LD   A,k6850Reset   ;Master reset
        OUT  (kACIA1Cont),A ;Write to ACIA control register
        LD   A,k6850Init    ;No int, RTS low, 8+1, /64
        OUT  (kACIA1Cont),A ;Write to ACIA control register
; Test 2, perform tests on chip following initialisation
        IN   A,(kACIA1Cont) ;Read status (control) register
        AND  k6850Mask2     ;Mask for known bits in control reg
        CP   k6850Test2     ;Test value following masking
;           RET  NZ             ;Return not found NZ flagged
        RET                 ;Return Z if found, NZ if not


; RC2014 serial 6850 input character
;   On entry: No parameters required
;   On exit:  A = Character input from the device
;             NZ flagged if character input
;             BC DE HL IX IY I AF' BC' DE' HL' preserved
; This function does not return until a character is available
getchar:
.if TESTMODE=1
        PUSH HL
        LD HL,(tbPtr)
        LD A,(HL)
        INC HL
        LD (tbPtr),HL
        POP HL
.else
        IN   A,(kACIA1Cont) ;Address of status register
        AND  $01            ;Receive byte available
        JR   Z, getchar     ;Return Z if no character
        IN   A,(kACIA1Data) ;Read data byte
.endif
        RET                 ;NZ flagged if character input


; RC2014 serial 6850 output character
;   On entry: A = Character to be output to the device
;   On exit:  If character output successful (eg. device was ready)
;               NZ flagged and A != 0
;             If character output failed (eg. device busy)
;               Z flagged and A = Character to output
;             BC DE HL IX IY I AF' BC' DE' HL' preserved
putchar:
        PUSH BC
        LD   C,kACIA1Cont   ;ACIA control register
        IN   B,(C)          ;Read ACIA control register
        BIT  k6850TxRdy,B   ;Transmit register full?
        POP  BC
        JR  Z, putchar      ;Return Z as character not output
        OUT  (kACIA1Data),A ;Write data byte
        OR   0xFF           ;Return success A=0xFF and NZ flagged
        RET
        
printdec:

;Number in hl to decimal ASCII
;Thanks to z80 Bits
;inputs:	hl = number to ASCII
;example: hl=300 outputs '00300'
;destroys: af, bc, hl, de used
DispHL:
        ld	bc,-10000
        call	Num1
        ld	bc,-1000
        call	Num1
        ld	bc,-100
        call	Num1
        ld	c,-10
        call	Num1
        ld	c,-1
Num1:	    ld	a,'0'-1
Num2:	    inc	a
        add	hl,bc
        jr	c,Num2
        sbc	hl,bc
        call putchar
        ret 
        
crlf:       
        LD A, $0A           ; Send a CRLF
        CALL putchar
        LD A, $0D
        CALL putchar
        RET
        
ok:         
        LD A, $4F           ; Print OK
        CALL putchar
        LD A, $4B
        CALL putchar
        RET            
        
        
printhex:

        ;Display a 16- or 8-bit number in hex.
DispHLhex:
; Input: HL
        ld  c,h
        call  OutHex8
        ld  c,l
OutHex8:
; Input: C
        ld  a,c
        rra
        rra
        rra
        rra
        call  Conv
        ld  a,c
Conv:
        and  $0F
        add  a,$90
        daa
        adc  a,$40
        daa
        call putchar  
        ret


; **********************************************************************			 
         
; $ A000 Start of primitive routines 

; **********************************************************************

         .ORG  $A000
         
space:       
        JP      (IY)
         
fetch:                          ; Fetch the value from the address placed on the top of the stack      
        POP     HL          ; 10t
        LD      E,(HL)      ; 7t
        INC     HL          ; 6t
        LD      D,(HL)      ; 7t
        PUSH    DE          ; 11t
        JP      (IY)        ; 8t
        
                            ; 49t 
        
         
store:                          ; Store the value at the address placed on the top of the stack
         POP    HL          ; 10t
         POP    DE          ; 10t
         LD     (HL),E      ; 7t
         INC    HL          ; 6t
         LD     (HL),D      ; 7t
         JP      (IY)       ; 8t
         
                            ; 48t
         
         
dup_:        POP     HL         ; Duplicate the top member of the stack
         PUSH    HL
         PUSH    HL
         JP      (IY)
         

swap:        POP     HL         ; Swap the top 2 elements of the stack
         POP     DE
         PUSH    HL
         PUSH    DE
         JP      (IY)
         
drop:                           ; Discard the top member of the stack
         POP     HL
         JP      (IY)
         
    

and_:        POP     DE                      ; 10t Bitwise AND the top 2 elements of the stack
	     POP     HL                      ; 10t
	     LD      A,E                     ; 4t
	     AND     L                       ; 4t
	     LD      L,A                     ; 4t
         LD      A,D                     ; 4t
         AND     H                       ; 4t
         LD      H,A                     ; 4t
         PUSH    HL                      ; 11t
         JP      (IY)                    ; 8t
         
                                         ; 63t
	
	
or_: 		 POP     DE             ; Bitwise OR the top 2 elements of the stack
	     POP     HL
	     LD      A,E
	     OR      L
	     LD      L,A
         LD      A,D
         OR      H
         LD      H,A
         PUSH    HL
         JP      (IY)
	
	
xor_:		 POP     DE            ; Bitwise XOR the top 2 elements of the stack
	     POP     HL
	     LD      A,E
	     XOR     L
	     LD      L,A
         LD      A,D
         XOR     H
         LD      H,A
         PUSH    HL
         JP      (IY)
         

add_:                               ; Add the top 2 members of the stack
         POP     DE             ; 10t
         POP     HL             ; 10t
         ADD     HL,DE          ; 11t
         PUSH    HL             ; 11t
         JP      (IY)           ; 8t
                                ; 50t
         
sub_:       						; Subtract the value 2nd on stack from top of stack 
		 POP     HL             ; 10t
		 POP     DE             ; 10t
         OR      A              ;  4t  clear the carry
		 SBC     HL,DE          ; 15t
		 PUSH    HL             ; 11t
		 JP      (IY)           ; 8t
		                        ; 58t

inv_:								; Bitwise INVert the top member of the stack
		 POP     HL
         LD A,   L
		 CPL					; Invert L
		 LD L,   A
		 LD A,   H
		 CPL					; Invert H
		 LD H,   A
		 PUSH    HL
		 JP      (IY)
		 
neg_:       						; NEGate the value on top of stack (2's complement)
		 POP     HL
         LD A,   L
		 CPL					; Invert L
		 LD L,   A
		 LD A,   H
		 CPL					; Invert H
		 LD H,   A
		 INC     HL             ; and add 1
		 PUSH    HL
		 JP      (IY)		             
         
         
dot_:        POP     HL
         PUSH    BC         ; Preserve the Instruction Pointer !
         CALL    printdec
         CALL    crlf
         POP     BC
         JP      (IY)
         
quit:        
         CALL    ok         ; Print OK and return to monitor
         CALL    crlf
         RET 
; **************************************************************************             
; def is used to create a colon definition
; When a colon is detected, the next character (usually uppercase alpha)
; is looked up in the vector table to get its associated code field address
; This CFA is held in HL
; The remainder of the characters in the text buffer are then copied
; up to a buffer beginning at that CFA until the end_def semicolon character 
; is found.
; ***************************************************************************

; NOTE: this code is not yet working JH

def_:                       ; Create a colon definition
        INC      BC
        LD       A,(BC)     ; Get the next character
        INC BC
                            ; Look up CFA in vector table
        ADD A,A             ; Double A to index even addresses
        PUSH HL             ; Save HL
        LD HL, VTABLE       ; Start address of jump table         
        LD L,A              ; Index into table
        LD (HL),C           ; Save low byte of IP in CFA
        INC HL              
        LD (HL),B           ; Save high byte of IP in CFA+1
        POP HL              ; Restore HL

nextbyte:                   ; Skip to end of defintion   
        LD A,(BC)           ; Get the next character
        INC BC              ; Point to next character
        CP ";"              ; Is it a semicolon 
        JR z, end_def       ; end the definition
        JR  nextbyte        ; get the next element
        
end_def:    
        LD (HL), A          ; Store the semicolon at end of definition
        INC HL
        LD A, $0D
       
        LD (HL), A          ; and a final Newline
        
        PUSH BC

        JP (IY)             


	            
ret_:
        LD C,(IX+0)         ; Restore Instruction pointer
        INC IX              
        LD B,(IX+0)
        INC IX                  
        JP (IY)             

; ***********************************************************************************
; Loop Handling Code
; 
; On finding a left bracket, the interpreter copies the code to a loop buffer
; beginning at loopstart, until it finds a right bracket 
; Putting the loop code at a fixed address makes it easier to execute multiple times
; The loopcount is held in RAM at user variable i so that it can be used within the loop
; ***********************************************************************************

begin_:                         ; Left parentesis begins a loop

        POP  HL             ; Get the loopcounter off the stack
        LD  (loopcount), HL ; Store the Loop counter in variable i
        LD  DE,loopstart    ; Loop code is then copied to buffer at loopstart 

loopbyte:   INC BC              ; Point to next character after the (
        LD A, (BC)          ; Get the next character
        CP $29              ; Is it a right bracket $29
        JR z, end_loop      ; end the code copy
        LD (DE), A          ; store the character at the loop buffer
        INC DE
        JR  loopbyte        ; get the next element

end_loop:   LD (DE), A          ; Store the closing bracket at the end of the loop           semicolon at end of definition
        LD A, $0D
        INC DE
        LD (DE), A          ; and a final Newline
        
        DEC  BC             ; IP now points to the loop terminator )
        
        JP   (IY)           ; Execute the closing  )
        
;*************************************************************************            
; This code executes the loop
; The loopcount is retrieved from RAM and loaded into HL
; The IP is set to point to the start of the loop
; HL is checked for zero and if zero the loop is terminated
; HL is decremented and stored back in the loopcount variable
; JP NEXT will execute each instruction between the brackets in turn
; including the closing ) which causes this routine to repeat until HL is zero
; ************************************************************************
end_:    
        LD HL, (loopcount)    ; get the loop count
        
loopagain:  LD  BC, loopstart -1  ; Point the IP to loopstart

        LD DE,     $0000  
        OR       A            ; reset the carry flag
        SBC      HL,DE        ; test if HL = 0
        JR      Z, finish     ; end the loop


        DEC     HL            ; While HL > zero
        LD  (loopcount), HL   ; preserve the loop count
        JP      (IY)          ; execute the next instruction
         
finish:     
        JP     interpret         ; back to OK prompt




tick:                               ; execute a loop
        LD    BC, loopstart - 1
        JP   (IY) 
        
; **************************************************************************             
; Print the string between underscores
str_:       ;PUSH BC           ; save the IP                    
        INC BC
        
nextchar:            
        LD A, (BC)
        INC BC
        CP $5F              ; _ is the string terminator
        JR Z,stringend
        CALL putchar
    
        JR   nextchar
        
       
        
stringend:  CALL crlf
        JP   (IY)                        

; ********************************************************           
; More Arithmetic Operations   MUL, DIV and MOD
;*********************************************************

mul_:                           ; 16-bit multiply  

        POP  DE             ; get first value
        POP  HL
        PUSH BC             ; Preserve the IP
        LD B,H              ; BC = 2nd value
        LD C,L
        
        LD HL,0
        LD A,16
Mul_Loop_1:
        ADD HL,HL
        RL E
        RL D
        JR NC,$+6
        ADD HL,BC
        JR NC,$+3
        INC DE
        DEC A
        JR NZ,Mul_Loop_1
        
        POP  BC
   
        PUSH DE
        PUSH HL

        JP       (IY)
        
; *********************************************************************            
; This divides DE by BC, storing the result in DE, remainder in HL
; *********************************************************************
div_:  

        POP  DE             ; get first value
        POP  HL             ; get 2nd value
        PUSH BC             ; Preserve the IP
        LD B,H              ; BC = 2nd value
        LD C,L
                              
                        ;1281-2x, x is at most 16
        ld a,16         ;7
        ld hl,0         ;10
        jp $+5          ;10  
    
DivLoop:

        add hl,bc       ;--
        dec a           ;64
        JR Z, div_end   ;86

        sla e           ;128
        rl d            ;128
        adc hl,hl       ;240
        sbc hl,bc       ;240
        jr nc,DivLoop   ;23|21
        inc e           ;--
        jp DivLoop+1

div_end:    
        POP  BC         ; Restore the IP
   
        PUSH DE         ; Push Result
        PUSH HL         ; Push remainder             

        JP       (IY) 
        
; ***************************************************************
; MOD is a 16 / 8 Division
; ***************************************************************

mod_:        
        POP  DE            ; get first value TOS
        POP  HL            ; get 2nd value   NOS
        PUSH BC            ; Preserve the IP
        LD B,16            ; C = 1st  value
        LD D,E
        
        
        ld b,16
        xor a
        
Div8_loop:            
        add hl,hl
        rla
        cp d
        jr c,Div8_next
        inc l
        sub d
Div8_next:            
        
        djnz Div8_loop
        
        
        POP  BC         ; Restore the IP
        
        LD   D, 0
        LD   E, A
   
        PUSH DE         ; Push Remainder 
        PUSH HL         ; Push Quotient      
        
        
        
        JP       (IY)  
   
         
lit_:       
        JP       (IY)             
        
       

num_:
        JP       (IY)
         
; **************************************************************************
;  Comparison Operations
;  Put 1 on stack if condition is true and 0 if it is false
; **************************************************************************

lt_:         POP      DE
        POP      HL
        OR       A         ; reset the carry flag
        SBC      HL,DE
        JP      M, setone
        LD      HL,0
        JR      setzero
           
        
eq_:
        POP      HL
        POP      DE
        OR       A         ; reset the carry flag
        SBC      HL,DE
        JR      Z, setone
        LD      HL,0
        JR      setzero
        
        
gt_:            
        POP      HL
        POP      DE
        OR       A         ; reset the carry flag
        SBC      HL,DE
        JP      M, setone
        LD      HL,0
        JR      setzero
  
setone:      LD      HL,1             
        
setzero:     PUSH     HL
        JP       (IY)            
        
        
query:
        JP       (IY) 
        
open:      
        JP       (IY)
        
close:      
        JP       (IY)
        
        
        
save:       
        JP       (IY)
        
load:      
        JP       (IY)
        
del_:      
        JP       (IY) 
         
        .ORG ROMSTART + ROMSIZE

RAMSTART:
        DS DSIZE
DSTACK:        

        DS RSIZE
RSTACK:        

; ****************************************************************
; Vector Table - holds the 16-bit target addresses of 
; the 96 possible functions as used by the dispatch routine
; 192 bytes
; ****************************************************************

VTABLE:
        DS VTSIZE
HERE:
        DW 0
HERE1:
        DW 0
DEFINE:
        DB 0

.if TESTMODE=1

tbPtr:
        DW 0

.endif
    
HEAPSTART:         
             
             


            