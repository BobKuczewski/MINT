0000                             ; *************************************************************************
0000                             ; 
0000                             ;        MINT_8 micro-interpreter based on SIMPL
0000                             ; 
0000                             ;        Ken Boak July 2021
0000                             ; 
0000                             ;        Includes serial routines getchar and putchar
0000                             ;        printstring
0000                             ;        printdec
0000                             ;        printhex
0000                             ;        crlf
0000                             ; 
0000                             ;        Register Assignment:
0000                             ; 
0000                             ;        BC is the instruction pointer IP
0000                             ;        DE is a working register and 2nd on stack NOS
0000                             ;        HL is a working register and Top of stack TOS
0000                             ;        SP is data stack pointer
0000                             ; 
0000                             ;        MINT consists of 4 major sections:
0000                             ; 
0000                             ;        1.  An interpreter kernel and serial interface routines
0000                             ; 
0000                             ;        2.  A vector table to dispatch the 96 possible opcodes
0000                             ; 
0000                             ;        3.  A text buffer area to hold keyboard input and User routines
0000                             ; 
0000                             ;        4.  An area containing the Primitive function code fields
0000                             ; 
0000                             ; ***********************************************************************
0000                             ; 
0000                             ; 
0000                TABSTART:   EQU   $82   ; High Address of Vector table
0000                             ; 
0000                TEXTBUF:   EQU   $8100   ; Input text buffer
0000                             ; 
0000                STRINGBUF:   EQU   $8800   
0000                             ; 
0000                             ; 
8000                          .ORG   $8000   
8000                             ; *******************************************************************         
8000                             ; Wait for a character from the serial input (keyboard) 
8000                             ; and store it in the text buffer. Keep accepting characters,
8000                             ; increasing the instruction pointer BC - until a newline received.
8000                             ; *******************************************************************
8000                             ; 
8000                             ; 
8000   01 00 81     INCHAR:   LD   BC,textbuf   ; input buffer is at $8100      
8003                             ; 
8003   CD 71 80     WAITCHAR:   CALL   getchar   ; loop around waiting for character
8006                             ; 
8006   FE 0A                  CP   $0A   ; Less than $0A
8008   38 0F                  JR   C,endchar   ; Return char
800A   FE 7F                  CP   $7F   ; Greater or equal to $7F
800C   30 0B                  JR   NC,endchar   
800E                             ; 
800E   02                     LD   (BC),A   ; store the character in textbuf
800F   03                     INC   BC   
8010   FE 0D                  CP   $0D   ; is it a newline?
8012   28 05                  JR   Z,endchar   
8014                             ; 
8014   CD 7A 80               CALL   putchar   ; echo character to screen
8017                             ; 
8017   18 EA                  JR   waitchar   ; wait for next character
8019                             ; 
8019   3E 0D        ENDCHAR:   LD   A,$0D   ; Send out a CRLF
801B   CD 7A 80               CALL   putchar   
801E   3E 0A                  LD   A,$0A   
8020   CD 7A 80               CALL   putchar   
8023                             ; 
8023                             ; ********************************************************************************
8023                             ; Number Handling Routine - converts numeric ascii string to a 16-bit number in HL
8023                             ; On receipt of a newline character, reset BC to the start of the text buffer
8023                             ; Read the first character. If not a number (0-9) jump to the dispatch routine
8023                             ;			
8023                             ; Number characters ($30 to $39) are converted to digits by subtracting $30
8023                             ; and then added into the L register. (HL forms a 16-bit accumulator)
8023                             ; Fetch the next character, if it is a number, multiply contents of HL by 10
8023                             ; and then add in the next digit. Repeat this until a non-number character is 
8023                             ; detected. Add in the final digit so that HL contains the converted number.
8023                             ; Push HL onto the stack and proceed to the dispatch routine.
8023                             ; ********************************************************************************
8023                             ; 
8023   01 FF 80               LD   BC,textbuf-1   ; Instructions begin at $8100
8026                             ; 
8026   21 00 00     NEXT:     LD   HL,$0000   ; 10t   Clear HL to accept new number
8029   03                     INC   BC   ; 6t    Increment the IP
802A   0A                     LD   A,(BC)   ; 7t    Get the next character
802B   FE 30                  CP   $30   ; 7t    Less that $30
802D   38 20                  JR   C,dispatch   ; 7/12t Not a number
802F   FE 3A                  CP   $3A   ; 7t    Greater or equal to $3A
8031   30 1C                  JR   NC,dispatch   ; 7/12t Not a number
8033                             ; 
8033   D6 30                  SUB   $30   ; 7t    Form decimal digit
8035   85                     ADD   A,L   ; 4t    Add into bottom of HL
8036   6F                     LD   L,A   ; 4t
8037                             ; 
8037                NUMBER1:      
8037   03                     INC   BC   ; 6t    Increment IP
8038   0A                     LD   A,(BC)   ; 7t    Get the next character
8039   FE 30                  CP   $30   ; 7t    Less than $30
803B   38 11                  JR   C,endnum   ; 7/12t Not a number / end of number
803D   FE 3A                  CP   $3A   ; 7t    Greater or equal to $3A
803F   30 0D                  JR   NC,endnum   ; 7/12t Not a number / end of number
8041                             ; 
8041                TIMES10:      ; Multiply digit(s) in HL by 10
8041   29                     ADD   HL,HL   ; 11t    2 X
8042   5D                     LD   E,L   ;  4t    LD DE,HL
8043   54                     LD   D,H   ;  4t
8044   29                     ADD   HL,HL   ; 11t    4 X
8045   29                     ADD   HL,HL   ; 11t    8 X
8046   19                     ADD   HL,DE   ; 11t    10 X
8047                             ; 52t cycles
8047                             ; 
8047   D6 30                  SUB   $30   ;  7t   Form next decimal digit in A
8049   85                     ADD   A,L   ;  4t   Add into bottom of HL
804A   6F                     LD   L,A   ;  4t
804B                             ;  15t cycles
804B                             ; 
804B   C3 37 80               JP   number1   
804E                             ; 
804E                ENDNUM:      
804E   E5                     PUSH   HL   ; 11t   Put the number on the stack
804F                             ; 
804F                             ; ********************************************************************************
804F                             ; Dispatch Routine.
804F                             ; The Instruction Pointer IP BC is pushed to preserve its contents.
804F                             ; The current character from the text buffer is temporarily held in A.
804F                             ; It is doubled so that it forms an even number and will point to even address.
804F                             ; B is loaded with the high byte of the vector table tabstart and the doubled		 
804F                             ; value of A is loaded into C, so that it indexes into the vector table.
804F                             ; At the selected table location is a 2-byte jump address to the selected function
804F                             ; This target jump address is loaded into HL, and BC is restored.
804F                             ; The routine uses HL to jump to the selected function.
804F                             ; *********************************************************************************
804F                             ; 
804F                DISPATCH:      ; The character at IP is not a number
804F                             ; 
804F   C5                     PUSH   BC   ; 11t   Push the current IP
8050   87                     ADD   A,A   ; 4t    Double A to index even addresses
8051   06 82                  LD   B,tabstart   ; 7t    Start address of jump table         
8053   4F                     LD   C,A   ; 4t    Index into table
8054   0A                     LD   A,(BC)   ; 7t    get low jump address
8055   6F                     LD   L,A   ; 4t    and put into L
8056   03                     INC   BC   ; 6t
8057   0A                     LD   A,(BC)   ; 7t    Get high jump address
8058   67                     LD   H,A   ; 4t    and put into H
8059   C1                     POP   BC   ; 10t   Get IP back
805A   E9                     JP   (HL)   ; 4t    Jump to routine
805B                             ; 68t cycles
805B                             ; 
805B                             ; ************************SERIAL HANDLING ROUTINES**********************        
805B                             ; 
805B                             ;        Includes drivers for 68B50 ACIA 
805B                             ;		 serial interface I/O primitive routines getchar and putchar
805B                             ;        printstring
805B                             ;        printdec
805B                             ;        printhex
805B                             ;        crlf         
805B                             ; 
805B                             ; **********************************************************************
805B                             ; **  Device Driver                             by Stephen C Cousins  **
805B                             ; **  Hardware:  RC2014                                               **
805B                             ; **  Interface: Serial 6850 ACIA                                     **
805B                             ; **********************************************************************
805B                             ; 
805B                             ; This module is the driver for the RC2014 serial I/O interface which is
805B                             ; based on the 6850 Asynchronous Communications Interface Adapter (ACIA)
805B                             ; 
805B                             ; Base addresses for ACIA externally defined. eg:
805B                KACIA1:   EQU   0x80   ;Base address of serial ACIA #1
805B                KACIA2:   EQU   0x80   ;Base address of serial ACIA #2
805B                             ; 
805B                             ; RC2014 addresses for 68B50 number 2:
805B                             ; 0x40   Control registers (read and write)
805B                             ; 0x41   Data registers (read and write)
805B                             ; 
805B                             ; Control registers (read and write)
805B                             ; Bit   Control write              Control read
805B                             ;  0    Counter divide select 1    Receive data register full
805B                             ;  1    Counter divide select 2    Transmit data register empty
805B                             ;  2    Word select 1              Data carrier detect (/DCD) input
805B                             ;  3    Word seelct 2              Clear to send (/CTS) input
805B                             ;  4    Word select 3              Framing error
805B                             ;  5    Transmit contol 1          Receiver overrun
805B                             ;  6    Transmit control 2         Parity error
805B                             ;  7    Receive interrupt enable   Interrupt request
805B                             ; 
805B                             ; Control register write
805B                             ; Bit   7   6   5   4   3   2   1   0
805B                             ;       |   |   |   |   |   |   |   |
805B                             ;       |   |   |   |   |   |   0   0     Clock divide 1
805B                             ;       |   |   |   |   |   |   0   1     Clock divide 16
805B                             ; >     |   |   |   |   |   |   1   0  >  Clock divide 64
805B                             ;       |   |   |   |   |   |   1   1     Master reset
805B                             ;       |   |   |   |   |   |
805B                             ;       |   |   |   0   0   0     7 data bits, even parity, 2 stop bits
805B                             ;       |   |   |   0   0   1     7 data bits, odd parity,  2 stop bits
805B                             ;       |   |   |   0   1   0     7 data bits, even parity, 1 stop bit
805B                             ;       |   |   |   0   1   1     7 data bits, odd parity,  1 stop bit
805B                             ;       |   |   |   1   0   0     8 data bits, no parity,   2 stop bits
805B                             ;       |   |   |   1   0   1  >  8 data bits, no parity,   1 stop bit
805B                             ;       |   |   |   1   1   0     8 data bits, even parity, 1 stop bit
805B                             ;       |   |   |   1   1   1     8 data bits, odd parity,  1 stop bit
805B                             ;       |   |   |
805B                             ;       |   0   0  >  /RTS = low (ready), tx interrupt disabled
805B                             ;       |   0   1     /RTS = low (ready), tx interrupt enabled
805B                             ;       |   1   0     /RTS = high (not ready), tx interrupt disabled 
805B                             ;       |   1   1     /RTS = low, tx break, tx interrupt disabled
805B                             ;       |
805B                             ;       0  >  Receive interrupt disabled
805B                             ;       1     Receive interrupt enabled
805B                             ; 
805B                             ; Control register read
805B                             ; Bit   7   6   5   4   3   2   1   0
805B                             ;       |   |   |   |   |   |   |   |
805B                             ;       |   |   |   |   |   |   |   +-------  Receive data register full
805B                             ;       |   |   |   |   |   |   +-------  Transmit data register empty
805B                             ;       |   |   |   |   |   +-------  Data carrier detect (/DCD)
805B                             ;       |   |   |   |   +-------  Clear to send (/CTS)
805B                             ;       |   |   |   +-------  Framing error
805B                             ;       |   |   +-------  Receiver overrun 
805B                             ;       |   +-------  Parity error
805B                             ;       +-------  Interrupt request
805B                             ; 
805B                             ; 6850 #1 registers derived from base address (above)
805B                KACIA1CONT:   EQU   kACIA1+0   ;I/O address of control register
805B                KACIA1DATA:   EQU   kACIA1+1   ;I/O address of data register
805B                             ; 6850 #2 registers derived from base address (above)
805B                KACIA2CONT:   EQU   kACIA2+0   ;I/O address of control register
805B                KACIA2DATA:   EQU   kACIA2+1   ;I/O address of data register
805B                             ; 
805B                             ; Control register values
805B                K6850RESET:   EQU   0b00000011   ;Master reset
805B                K6850INIT:   EQU   0b00010110   ;No int, RTS low, 8+1, /64
805B                             ; 
805B                             ; Status (control) register bit numbers
805B                K6850RXRDY:   EQU   0   ;Receive data available bit number
805B                K6850TXRDY:   EQU   1   ;Transmit data empty bit number
805B                             ; 
805B                             ; Device detection, test 1
805B                             ; This test just reads from the devices' status (control) register
805B                             ; and looks for register bits in known states:
805B                             ; /CTS input bit = low
805B                             ; /DCD input bit = low
805B                             ; WARNING
805B                             ; Sometimes at power up the Tx data reg empty bit is zero, but
805B                             ; recovers after device initialised. So test 1 excludes this bit.
805B                K6850MASK1:   EQU   0b00001100   ;Mask for known bits in control reg
805B                K6850TEST1:   EQU   0b00000000   ;Test value following masking
805B                             ; 
805B                             ; Device detection, test 2
805B                             ; This test just reads from the devices' status (control) register
805B                             ; and looks for register bits in known states:
805B                             ; /CTS input bit = low
805B                             ; /DCD input bit = low
805B                             ; Transmit data register empty bit = high
805B                K6850MASK2:   EQU   0b00001110   ;Mask for known bits in control reg
805B                K6850TEST2:   EQU   0b00000010   ;Test value following masking
805B                             ; 
805B                             ; RC2014 serial 6850 initialise
805B                             ;   On entry: No parameters required
805B                             ;   On exit:  Z flagged if device is found and initialised
805B                             ;             AF BC DE HL not specified
805B                             ;             IX IY I AF" BC" DE" HL" preserved
805B                             ; If the device is found it is initialised
805B                SERIAL_INIT:      
805B                             ; First look to see if the device is present
805B                             ; Test 1, just read from chip, do not write anything
805B   DB 80                  IN   A,(kACIA1Cont)   ;Read status (control) register
805D   E6 00                  AND   k6850Mask1   ;Mask for known bits in control reg
805F   FE 00                  CP   k6850Test1   ;and check for known values
8061   C0                     RET   NZ   ;If not found return with NZ flag
8062                             ; Attempt to initialise the chip
8062   3E 00                  LD   A,k6850Reset   ;Master reset
8064   D3 80                  OUT   (kACIA1Cont),A   ;Write to ACIA control register
8066   3E 00                  LD   A,k6850Init   ;No int, RTS low, 8+1, /64
8068   D3 80                  OUT   (kACIA1Cont),A   ;Write to ACIA control register
806A                             ; Test 2, perform tests on chip following initialisation
806A   DB 80                  IN   A,(kACIA1Cont)   ;Read status (control) register
806C   E6 00                  AND   k6850Mask2   ;Mask for known bits in control reg
806E   FE 00                  CP   k6850Test2   ;Test value following masking
8070                             ;           RET  NZ             ;Return not found NZ flagged
8070   C9                     RET      ;Return Z if found, NZ if not
8071                             ; 
8071                             ; 
8071                             ; RC2014 serial 6850 input character
8071                             ;   On entry: No parameters required
8071                             ;   On exit:  A = Character input from the device
8071                             ;             NZ flagged if character input
8071                             ;             BC DE HL IX IY I AF" BC" DE" HL" preserved
8071                             ; This function does not return until a character is available
8071                GETCHAR:      
8071   DB 80                  IN   A,(kACIA1Cont)   ;Address of status register
8073   E6 01                  AND   $01   ;Receive byte available
8075   28 FA                  JR   Z,getchar   ;Return Z if no character
8077   DB 81                  IN   A,(kACIA1Data)   ;Read data byte
8079   C9                     RET      ;NZ flagged if character input
807A                             ; 
807A                             ; 
807A                             ; RC2014 serial 6850 output character
807A                             ;   On entry: A = Character to be output to the device
807A                             ;   On exit:  If character output successful (eg. device was ready)
807A                             ;               NZ flagged and A != 0
807A                             ;             If character output failed (eg. device busy)
807A                             ;               Z flagged and A = Character to output
807A                             ;             BC DE HL IX IY I AF" BC" DE" HL" preserved
807A                PUTCHAR:      
807A   C5                     PUSH   BC   
807B   0E 80                  LD   C,kACIA1Cont   ;ACIA control register
807D   ED 40                  IN   B,(C)   ;Read ACIA control register
807F   00                     BIT   k6850TxRdy,B   ;Transmit register full?
8080   C1                     POP   BC   
8081   28 F7                  JR   Z,putchar   ;Return Z as character not output
8083   D3 81                  OUT   (kACIA1Data),A   ;Write data byte
8085   F6 FF                  OR   0xFF   ;Return success A=0xFF and NZ flagged
8087   C9                     RET      
8088                             ; 
8088                             ; 
8088                PRINTSTRING:      
8088                             ; 
8088   21 00 88               LD   HL,stringbuf   
808B                NEXTCHAR:      
808B   7E                     LD   A,(HL)   
808C   23                     INC   HL   
808D   FE 00                  CP   $00   
808F   28 05                  JR   Z,stringend   
8091   CD 7A 80               CALL   putchar   
8094                             ; 
8094                             ;            LD B,20
8094                             ; L1:        DJNZ L1
8094                             ;            CALL  putchar
8094                             ; 
8094   18 F5                  JR   nextchar   
8096                             ; 
8096   C9           STRINGEND:   RET      
8097                             ; 
8097                             ; 
8097                PRINTDEC:      
8097                             ; 
8097                             ;Number in hl to decimal ASCII
8097                             ;Thanks to z80 Bits
8097                             ;inputs:	hl = number to ASCII
8097                             ;example: hl=300 outputs "00300"
8097                             ;destroys: af, bc, hl, de used
8097                DISPHL:      
8097   01 F0 D8               LD   bc,-10000   
809A   CD B0 80               CALL   Num1   
809D   01 18 FC               LD   bc,-1000   
80A0   CD B0 80               CALL   Num1   
80A3   01 9C FF               LD   bc,-100   
80A6   CD B0 80               CALL   Num1   
80A9   0E F6                  LD   c,-10   
80AB   CD B0 80               CALL   Num1   
80AE   0E FF                  LD   c,-1   
80B0   3E 2F        NUM1:     LD   a,"0"-1   
80B2   3C           NUM2:     INC   a   
80B3   09                     ADD   hl,bc   
80B4   38 FC                  JR   c,Num2   
80B6   ED 42                  SBC   hl,bc   
80B8   CD 7A 80               CALL   putchar   
80BB   C9                     RET      
80BC                             ; 
80BC                             ; 
80BC   3E 0A        CRLF:     LD   A,$0A   
80BE   CD 7A 80               CALL   putchar   
80C1   3E 00                  LD   A,$OD   
80C3   CD 7A 80               CALL   putchar   
80C6   C9                     RET      
80C7                             ; 
80C7                             ; 
80C7                PRINTHEX:      
80C7                             ; 
80C7                             ;Display a 16- or 8-bit number in hex.
80C7                DISPHLHEX:      
80C7                             ; Input: HL
80C7   4C                     LD   c,h   
80C8   CD CC 80               CALL   OutHex8   
80CB   4D                     LD   c,l   
80CC                OUTHEX8:      
80CC                             ; Input: C
80CC   79                     LD   a,c   
80CD   1F                     RRA      
80CE   1F                     RRA      
80CF   1F                     RRA      
80D0   1F                     RRA      
80D1   CD D5 80               CALL   Conv   
80D4   79                     LD   a,c   
80D5                CONV:        
80D5   E6 0F                  AND   $0F   
80D7   C6 90                  ADD   a,$90   
80D9   27                     DAA      
80DA   CE 40                  ADC   a,$40   
80DC   27                     DAA      
80DD   CD 7A 80               CALL   putchar   
80E0   C9                     RET      
80E1                             ; 
80E1                             ; ****************************************************************
80E1                             ; Vector Table - holds the 16-bit target addresses of 
80E1                             ; the 96 possible functions as used by the dispatch routine
80E1                             ; 192 bytes
80E1                             ; ****************************************************************
8240                          .ORG   $8240   
8240                             ; 
8240                TABSTART:      ; Jump Table
8240                             ; 
8240   00 A0                  DW   space   ; 
8242   03 A0                  DW   store   ; !   
8244   06 A0                  DW   dup_   ; "
8246   0C A0                  DW   lit_   ; #
8248   0F A0                  DW   swap   ; $   
824A   19 A0                  DW   mod_   ; %   
824C   28 A0                  DW   and_   ; &
824E   16 A0                  DW   drop   ; '
8250   1C A0                  DW   begin_   ; (  
8252   1F A0                  DW   end_   ; )
8254   22 A0                  DW   mul_   ; *   
8256   4C A0                  DW   add_   ; +
8258   7F A0                  DW   quit   ; ,   
825A   53 A0                  DW   sub_   ; -
825C   78 A0                  DW   dot_   ; .
825E   25 A0                  DW   div_   ; /
8260   80 A0                  DW   num_   ; 0   
8262   80 A0                  DW   num_   ; 1  
8264   80 A0                  DW   num_   ; 2   
8266   80 A0                  DW   num_   ; 3
8268   80 A0                  DW   num_   ; 4   
826A   80 A0                  DW   num_   ; 5   
826C   80 A0                  DW   num_   ; 6   
826E   80 A0                  DW   num_   ; 7
8270   80 A0                  DW   num_   ; 8   
8272   80 A0                  DW   num_   ; 9  
8274   83 A0                  DW   def_   ; :  
8276   86 A0                  DW   ret_   ; ;
8278   89 A0                  DW   lt_   ; <
827A   8C A0                  DW   eq_   ; =   
827C   8F A0                  DW   gt_   ; >   
827E   92 A0                  DW   query   ; ?
8280                             ; 
8280   95 A0                  DW   fetch   ; @   
8282   20 A4                  DW   $A420   ; A 
8284   40 A4                  DW   $A440   ; B
8286   60 A4                  DW   $A460   ; C
8288   80 A4                  DW   $A480   ; D 
828A   A0 A4                  DW   $A4A0   ; E
828C   C0 A4                  DW   $A4C0   ; F
828E   E0 A4                  DW   $A4E0   ; G
8290   00 A5                  DW   $A500   ; H
8292   20 A5                  DW   $A520   ; I
8294   40 A5                  DW   $A540   ; J
8296   60 A5                  DW   $A560   ; K
8298   80 A5                  DW   $A580   ; L
829A   A0 A5                  DW   $A5A0   ; M
829C   C0 A5                  DW   $A5C0   ; N
829E   E0 A5                  DW   $A5E0   ; O
82A0   00 A6                  DW   $A600   ; P
82A2   20 A6                  DW   $A620   ; Q
82A4   40 A6                  DW   $A640   ; R
82A6   60 A6                  DW   $A660   ; S
82A8   80 A6                  DW   $A680   ; T
82AA   A0 A6                  DW   $A6A0   ; U
82AC   C0 A6                  DW   $A6C0   ; V
82AE   E0 A6                  DW   $A6E0   ; W
82B0   00 A7                  DW   $A700   ; X
82B2   20 A7                  DW   $A720   ; Y
82B4   40 A7                  DW   $A740   ; Z
82B6   98 A0                  DW   open   ; [
82B8   7F A0                  DW   quit   ; \
82BA   9B A0                  DW   close   ; ]
82BC   40 A0                  DW   xor_   ; ^
82BE   6C A0                  DW   neg_   ; _
82C0                             ; 
82C0   9E A0                  DW   tick   ; `   
82C2   20 A8                  DW   $A820   
82C4   40 A8                  DW   $A840   
82C6   60 A8                  DW   $A860   
82C8   80 A8                  DW   $A880   
82CA   A0 A8                  DW   $A8A0   
82CC   C0 A8                  DW   $A8C0   
82CE   E0 A8                  DW   $A8E0   
82D0   00 A9                  DW   $A900   
82D2   20 A9                  DW   $A920   
82D4   40 A9                  DW   $A940   
82D6   60 A9                  DW   $A960   
82D8   80 A9                  DW   $A980   
82DA   A0 A9                  DW   $A9A0   
82DC   C0 A9                  DW   $A9C0   
82DE   E0 A9                  DW   $A9E0   
82E0   00 AA                  DW   $AA00   
82E2   20 AA                  DW   $AA20   
82E4   40 AA                  DW   $AA40   
82E6   60 AA                  DW   $AA60   
82E8   80 AA                  DW   $AA80   
82EA   A0 AA                  DW   $AAA0   
82EC   C0 AA                  DW   $AAC0   
82EE   E0 AB                  DW   $ABE0   
82F0   00 AB                  DW   $AB00   
82F2   20 AB                  DW   $AB20   
82F4   40 AB                  DW   $AB40   
82F6   A1 A0                  DW   save   ; {
82F8   34 A0                  DW   or_   ; |   
82FA   A4 A0                  DW   load   ; }   
82FC   61 A0                  DW   inv_   ; ~   
82FE   A7 A0                  DW   del_   ; BS
8300                             ; 
8300                             ; **********************************************************************			 
8300                             ; 
8300                             ; $ A000 Start of primitive routines 
8300                             ; 
8300                             ; **********************************************************************
8300                             ; 
A000                          .ORG   $A000   
A000                             ; 
A000                SPACE:       
A000   C3 26 80               JP   NEXT   
A003                             ; 
A003                             ; 
A003                             ; 
A003                STORE:       
A003   C3 26 80               JP   NEXT   
A006                             ; 
A006   E1           DUP_:     POP   HL   
A007   E5                     PUSH   HL   
A008   E5                     PUSH   HL   
A009   C3 26 80               JP   NEXT   
A00C                             ; 
A00C                LIT_:        
A00C   C3 26 80               JP   NEXT   
A00F                             ; 
A00F   E1           SWAP:     POP   HL   
A010   D1                     POP   DE   
A011   E5                     PUSH   HL   
A012   D5                     PUSH   DE   
A013   C3 26 80               JP   NEXT   
A016                             ; 
A016                DROP:        
A016   C3 26 80               JP   NEXT   
A019                             ; 
A019                MOD_:        
A019   C3 26 80               JP   NEXT   
A01C                             ; 
A01C                BEGIN_:      
A01C   C3 26 80               JP   NEXT   
A01F                             ; 
A01F                END_:        
A01F   C3 26 80               JP   NEXT   
A022                             ; 
A022                MUL_:        
A022   C3 26 80               JP   NEXT   
A025                             ; 
A025                DIV_:        
A025   C3 26 80               JP   NEXT   
A028                             ; 
A028   D1           AND_:     POP   DE   ; 10t
A029   E1                     POP   HL   ; 10t
A02A   7B                     LD   A,E   ; 4t
A02B   A5                     AND   L   ; 4t
A02C   6F                     LD   L,A   ; 4t
A02D   7A                     LD   A,D   ; 4t
A02E   A4                     AND   H   ; 4t
A02F   67                     LD   H,A   ; 4t
A030   E5                     PUSH   HL   ; 11t
A031   C3 26 80               JP   NEXT   ; 10t
A034                             ; 
A034                             ; 
A034   D1           OR_:      POP   DE   
A035   E1                     POP   HL   
A036   7B                     LD   A,E   
A037   B5                     OR   L   
A038   6F                     LD   L,A   
A039   7A                     LD   A,D   
A03A   B4                     OR   H   
A03B   67                     LD   H,A   
A03C   E5                     PUSH   HL   
A03D   C3 26 80               JP   NEXT   
A040                             ; 
A040                             ; 
A040   D1           XOR_:     POP   DE   
A041   E1                     POP   HL   
A042   7B                     LD   A,E   
A043   AD                     XOR   L   
A044   6F                     LD   L,A   
A045   7A                     LD   A,D   
A046   AC                     XOR   H   
A047   67                     LD   H,A   
A048   E5                     PUSH   HL   
A049   C3 26 80               JP   NEXT   
A04C                             ; 
A04C   D1           ADD_:     POP   DE   
A04D   E1                     POP   HL   
A04E   19                     ADD   HL,DE   
A04F   E5                     PUSH   HL   
A050   C3 26 80               JP   NEXT   
A053                             ; 
A053                SUB_:        ; Subtract the value 2nd on stack from top of stack 
A053   E1                     POP   HL   
A054   D1                     POP   DE   
A055   7B                     LD   A,E   
A056   2F                     CPL      ; Invert E
A057   5F                     LD   E,A   
A058   7A                     LD   A,D   
A059   2F                     CPL      ; Invert D
A05A   57                     LD   D,A   
A05B   13                     INC   DE   ; Add 1 to DE
A05C   19                     ADD   HL,DE   
A05D   E5                     PUSH   HL   
A05E   C3 26 80               JP   NEXT   
A061                             ; 
A061                INV_:        ; Bitwise INVert the top member of the stack
A061   E1                     POP   HL   
A062   7D                     LD   A,L   
A063   2F                     CPL      ; Invert L
A064   6F                     LD   L,A   
A065   7C                     LD   A,H   
A066   2F                     CPL      ; Invert H
A067   67                     LD   H,A   
A068   E5                     PUSH   HL   
A069   C3 26 80               JP   NEXT   
A06C                             ; 
A06C                NEG_:        ; NEGate the value on top of stack (2's complement)
A06C   E1                     POP   HL   
A06D   7D                     LD   A,L   
A06E   2F                     CPL      ; Invert L
A06F   6F                     LD   L,A   
A070   7C                     LD   A,H   
A071   2F                     CPL      ; Invert H
A072   67                     LD   H,A   
A073   23                     INC   HL   
A074   E5                     PUSH   HL   
A075   C3 26 80               JP   NEXT   
A078                             ; 
A078                             ; 
A078   E1           DOT_:     POP   HL   
A079   CD 97 80               CALL   printdec   
A07C   CD BC 80               CALL   crlf   
A07F                             ; JP      NEXT
A07F                             ; 
A07F   C9           QUIT:     RET      
A080                             ; 
A080                             ; 
A080                NUM_:        
A080   C3 26 80               JP   NEXT   
A083                             ; 
A083                DEF_:        
A083   C3 26 80               JP   NEXT   
A086                             ; 
A086                RET_:        
A086   C3 26 80               JP   NEXT   
A089                             ; 
A089                LT_:         
A089   C3 26 80               JP   NEXT   
A08C                             ; 
A08C                EQ_:         
A08C   C3 26 80               JP   NEXT   
A08F                             ; 
A08F                GT_:         
A08F   C3 26 80               JP   NEXT   
A092                             ; 
A092                QUERY:       
A092   C3 26 80               JP   NEXT   
A095                             ; 
A095                FETCH:       
A095   C3 26 80               JP   NEXT   
A098                             ; 
A098                OPEN:        
A098   C3 26 80               JP   NEXT   
A09B                             ; 
A09B                CLOSE:       
A09B   C3 26 80               JP   NEXT   
A09E                             ; 
A09E                TICK:        
A09E   C3 26 80               JP   NEXT   
A0A1                             ; 
A0A1                SAVE:        
A0A1   C3 26 80               JP   NEXT   
A0A4                             ; 
A0A4                LOAD:        
A0A4   C3 26 80               JP   NEXT   
A0A7                             ; 
A0A7                DEL_:        
A0A7   C3 26 80               JP   NEXT   
A0AA                             ; 


TABSTART:           8240 DEFINED AT LINE 405
                    > USED AT LINE 141
TEXTBUF:            8100 DEFINED AT LINE 35
                    > USED AT LINE 48
                    > USED AT LINE 84
STRINGBUF:          8800 DEFINED AT LINE 37
                    > USED AT LINE 322
INCHAR:             8000 DEFINED AT LINE 48
WAITCHAR:           8003 DEFINED AT LINE 50
                    > USED AT LINE 64
ENDCHAR:            8019 DEFINED AT LINE 66
                    > USED AT LINE 53
                    > USED AT LINE 55
                    > USED AT LINE 60
NEXT:               8026 DEFINED AT LINE 86
                    > USED AT LINE 515
                    > USED AT LINE 520
                    > USED AT LINE 525
                    > USED AT LINE 528
                    > USED AT LINE 534
                    > USED AT LINE 537
                    > USED AT LINE 540
                    > USED AT LINE 543
                    > USED AT LINE 546
                    > USED AT LINE 549
                    > USED AT LINE 552
                    > USED AT LINE 563
                    > USED AT LINE 575
                    > USED AT LINE 587
                    > USED AT LINE 593
                    > USED AT LINE 607
                    > USED AT LINE 618
                    > USED AT LINE 630
                    > USED AT LINE 642
                    > USED AT LINE 645
                    > USED AT LINE 648
                    > USED AT LINE 651
                    > USED AT LINE 654
                    > USED AT LINE 657
                    > USED AT LINE 660
                    > USED AT LINE 663
                    > USED AT LINE 666
                    > USED AT LINE 669
                    > USED AT LINE 672
                    > USED AT LINE 675
                    > USED AT LINE 678
                    > USED AT LINE 681
NUMBER1:            8037 DEFINED AT LINE 98
                    > USED AT LINE 120
TIMES10:            8041 DEFINED AT LINE 106
ENDNUM:             804E DEFINED AT LINE 122
                    > USED AT LINE 102
                    > USED AT LINE 104
DISPATCH:           804F DEFINED AT LINE 137
                    > USED AT LINE 90
                    > USED AT LINE 92
KACIA1:             0080 DEFINED AT LINE 171
                    > USED AT LINE 227
                    > USED AT LINE 228
KACIA2:             0080 DEFINED AT LINE 172
                    > USED AT LINE 230
                    > USED AT LINE 231
KACIA1CONT:         0080 DEFINED AT LINE 227
                    > USED AT LINE 270
                    > USED AT LINE 276
                    > USED AT LINE 278
                    > USED AT LINE 280
                    > USED AT LINE 294
                    > USED AT LINE 310
KACIA1DATA:         0081 DEFINED AT LINE 228
                    > USED AT LINE 297
                    > USED AT LINE 315
KACIA2CONT:         0080 DEFINED AT LINE 230
KACIA2DATA:         0081 DEFINED AT LINE 231
K6850RESET:         0000 DEFINED AT LINE 234
                    > USED AT LINE 275
K6850INIT:          0000 DEFINED AT LINE 235
                    > USED AT LINE 277
K6850RXRDY:         0000 DEFINED AT LINE 238
K6850TXRDY:         0001 DEFINED AT LINE 239
                    > USED AT LINE 312
K6850MASK1:         0000 DEFINED AT LINE 249
                    > USED AT LINE 271
K6850TEST1:         0000 DEFINED AT LINE 250
                    > USED AT LINE 272
K6850MASK2:         0000 DEFINED AT LINE 258
                    > USED AT LINE 281
K6850TEST2:         0000 DEFINED AT LINE 259
                    > USED AT LINE 282
SERIAL_INIT:        805B DEFINED AT LINE 267
GETCHAR:            8071 DEFINED AT LINE 293
                    > USED AT LINE 50
                    > USED AT LINE 296
PUTCHAR:            807A DEFINED AT LINE 308
                    > USED AT LINE 62
                    > USED AT LINE 67
                    > USED AT LINE 69
                    > USED AT LINE 314
                    > USED AT LINE 328
                    > USED AT LINE 361
                    > USED AT LINE 366
                    > USED AT LINE 368
                    > USED AT LINE 395
PRINTSTRING:        8088 DEFINED AT LINE 320
NEXTCHAR:           808B DEFINED AT LINE 323
                    > USED AT LINE 334
STRINGEND:          8096 DEFINED AT LINE 336
                    > USED AT LINE 327
PRINTDEC:           8097 DEFINED AT LINE 339
                    > USED AT LINE 634
DISPHL:             8097 DEFINED AT LINE 346
NUM1:               80B0 DEFINED AT LINE 356
                    > USED AT LINE 348
                    > USED AT LINE 350
                    > USED AT LINE 352
                    > USED AT LINE 354
NUM2:               80B2 DEFINED AT LINE 357
                    > USED AT LINE 359
CRLF:               80BC DEFINED AT LINE 365
                    > USED AT LINE 635
PRINTHEX:           80C7 DEFINED AT LINE 372
DISPHLHEX:          80C7 DEFINED AT LINE 375
OUTHEX8:            80CC DEFINED AT LINE 380
                    > USED AT LINE 378
CONV:               80D5 DEFINED AT LINE 389
                    > USED AT LINE 387
SPACE:              A000 DEFINED AT LINE 514
                    > USED AT LINE 407
STORE:              A003 DEFINED AT LINE 519
                    > USED AT LINE 408
DUP_:               A006 DEFINED AT LINE 522
                    > USED AT LINE 409
LIT_:               A00C DEFINED AT LINE 527
                    > USED AT LINE 410
SWAP:               A00F DEFINED AT LINE 530
                    > USED AT LINE 411
DROP:               A016 DEFINED AT LINE 536
                    > USED AT LINE 414
MOD_:               A019 DEFINED AT LINE 539
                    > USED AT LINE 412
BEGIN_:             A01C DEFINED AT LINE 542
                    > USED AT LINE 415
END_:               A01F DEFINED AT LINE 545
                    > USED AT LINE 416
MUL_:               A022 DEFINED AT LINE 548
                    > USED AT LINE 417
DIV_:               A025 DEFINED AT LINE 551
                    > USED AT LINE 422
AND_:               A028 DEFINED AT LINE 554
                    > USED AT LINE 413
OR_:                A034 DEFINED AT LINE 566
                    > USED AT LINE 501
XOR_:               A040 DEFINED AT LINE 578
                    > USED AT LINE 470
ADD_:               A04C DEFINED AT LINE 589
                    > USED AT LINE 418
SUB_:               A053 DEFINED AT LINE 595
                    > USED AT LINE 420
INV_:               A061 DEFINED AT LINE 609
                    > USED AT LINE 503
NEG_:               A06C DEFINED AT LINE 620
                    > USED AT LINE 471
DOT_:               A078 DEFINED AT LINE 633
                    > USED AT LINE 421
QUIT:               A07F DEFINED AT LINE 638
                    > USED AT LINE 419
                    > USED AT LINE 468
NUM_:               A080 DEFINED AT LINE 641
                    > USED AT LINE 423
                    > USED AT LINE 424
                    > USED AT LINE 425
                    > USED AT LINE 426
                    > USED AT LINE 427
                    > USED AT LINE 428
                    > USED AT LINE 429
                    > USED AT LINE 430
                    > USED AT LINE 431
                    > USED AT LINE 432
DEF_:               A083 DEFINED AT LINE 644
                    > USED AT LINE 433
RET_:               A086 DEFINED AT LINE 647
                    > USED AT LINE 434
LT_:                A089 DEFINED AT LINE 650
                    > USED AT LINE 435
EQ_:                A08C DEFINED AT LINE 653
                    > USED AT LINE 436
GT_:                A08F DEFINED AT LINE 656
                    > USED AT LINE 437
QUERY:              A092 DEFINED AT LINE 659
                    > USED AT LINE 438
FETCH:              A095 DEFINED AT LINE 662
                    > USED AT LINE 440
OPEN:               A098 DEFINED AT LINE 665
                    > USED AT LINE 467
CLOSE:              A09B DEFINED AT LINE 668
                    > USED AT LINE 469
TICK:               A09E DEFINED AT LINE 671
                    > USED AT LINE 473
SAVE:               A0A1 DEFINED AT LINE 674
                    > USED AT LINE 500
LOAD:               A0A4 DEFINED AT LINE 677
                    > USED AT LINE 502
DEL_:               A0A7 DEFINED AT LINE 680
                    > USED AT LINE 504
